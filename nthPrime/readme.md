To find the \( n \)th prime number, you can use a sieve method similar to the Sieve of Eratosthenes but with a twist. Instead of finding all primes up to a specific number, you need to generate primes until you find the \( n \)th one.

### Approach:

1. **Estimate an Upper Bound**: The \( n \)th prime number is approximately around \( n \ln(n) \) for large \( n \). To be safe, we often use a larger upper bound like \( n \ln(n) + n \ln(\ln(n)) \).
2. **Sieve of Eratosthenes**: Use the sieve method to find all primes up to the estimated upper bound.
3. **Check and Adjust**: If the sieve doesn't find enough primes, increase the bound and repeat.

### Python Implementation:

Here's how you can implement this approach in Python:

```python
import math

def sieve_of_eratosthenes(limit):
    """Generate a list of primes up to the given limit using the Sieve of Eratosthenes."""
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False

    for p in range(2, int(math.sqrt(limit)) + 1):
        if is_prime[p]:
            for multiple in range(p * p, limit + 1, p):
                is_prime[multiple] = False
    
    primes = [p for p in range(limit + 1) if is_prime[p]]
    return primes

def nth_prime(n):
    """Find the nth prime number."""
    if n < 1:
        raise ValueError("n must be a positive integer")

    # Use an upper bound estimate for the nth prime
    if n == 1:
        return 2  # The first prime number is 2
    
    # Estimate the upper bound for the nth prime number
    upper_bound = int(n * math.log(n) + n * math.log(math.log(n)))
    primes = []
    
    while len(primes) < n:
        primes = sieve_of_eratosthenes(upper_bound)
        upper_bound *= 2  # Double the bound if not enough primes are found
    
    return primes[n - 1]

# Example usage
n = 10001
print(f"The {n}th prime number is: {nth_prime(n)}")
```

### Explanation:

1. **Estimate an Upper Bound**:
   ```python
   upper_bound = int(n * math.log(n) + n * math.log(math.log(n)))
   ```
   - This estimates an initial upper bound for the \( n \)th prime number using known approximations.

2. **Generate Primes**:
   ```python
   primes = sieve_of_eratosthenes(upper_bound)
   ```
   - Use the Sieve of Eratosthenes to generate all primes up to the estimated bound.

3. **Check and Adjust**:
   ```python
   while len(primes) < n:
       upper_bound *= 2
       primes = sieve_of_eratosthenes(upper_bound)
   ```
   - If the number of primes found is less than \( n \), double the upper bound and repeat the process.

4. **Return the \( n \)th Prime**:
   ```python
   return primes[n - 1]
   ```
   - Return the \( n \)th prime from the list of generated primes.

### Summary:

- **Upper Bound Estimation**: Estimates the range to sieve for primes.
- **Sieve of Eratosthenes**: Efficiently finds all primes up to the estimated bound.
- **Adjustment Loop**: Ensures enough primes are generated by adjusting the bound as necessary.

This approach ensures you efficiently find the \( n \)th prime number with a balance of performance and simplicity.





